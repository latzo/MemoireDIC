\chapter*{Annexes}
\addcontentsline{toc}{chapter}{Annexes}
\markboth{chapter name}{Annexes}
%\minitoc
%\clearpage
\section{Top 10 Owasp 2017 : version affichée à HubSo}
\subsection{A1 : 2017 – FAILLE D’INJECTION}
Les failles d’injection telles que les injections SQL, NoSQL, OS et LDAP sont fréquentes dans les applications Web. L'injection se produit quand des données provenant de l'utilisateur sont envoyées à un interpréteur en tant qu'élément faisant partie d'une commande ou d'une requête. Les données hostiles de l'attaquant dupent l'interpréteur afin de l'amener à exécuter des commandes fortuites, à changer des données, etc.
\subsection{A2 : 2017 – VIOLATION DE GESTION D’AUTHENTIFICATION}
Les fonctions applicatives relatives à l'authentification et la gestion de session ne sont souvent pas mises en œuvre correctement, permettant aux attaquants de compromettre les mots de passe, clés, jetons de session, ou d'exploiter d'autres failles d'implémentation pour s'approprier les identités d'autres utilisateurs.
\subsection{A3 : 2017 – EXPOSITION DE DONNEES SENSIBLES}
L’exposition de données sensibles peut se produire lorsque des fonctions de sécurité adéquates ne sont pas appliquées sur les données ou sont appliquées de façon incorrecte permettant ainsi  aux attaquants de dérober des informations sensibles telles que des mots de passe, des informations de paiement, des adresses ou toute autre information pouvant être d’une certaine valeur pour l’attaquant. Les données sensibles doivent être bien protégées à la fois au stockage et durant leur transport et des précautions particulières doivent être prises lorsqu’elles sont échangées avec un navigateur Web.
\subsection{A4 : 2017 – ATTAQUE XXE}
Une attaque XXE est un type d’attaque contre un analyseur syntaxique XML. Cette attaque se produit lorsqu’un fichier XML contenant une référence à une entité externe est traité par un analyseur XML mal configuré. Les attaquants peuvent facilement exploiter les vulnérabilités dans ces analyseurs XML, en leur donnant des fichiers XML malveillants qui peuvent contenir du code indésirable. Cette attaque peut mener à la divulgation de données confidentielles, au déni de service, à la falsification des requêtes côté serveur, à l'analyse des ports du point de vue de la machine où se trouve l'analyseur et à d'autres impacts.
\subsection{A5 : 2017 – VIOLATION DE CONTRÔLE D’ACCES}
Le contrôle d’accès permet de spécifier ce qu’il est permis aux utilisateurs authentifiés de faire sur une application. Pour mettre en place un contrôle d’accès adéquat, il faut s’assurer que de bonnes vérifications d’autorisation et une bonne authentification permettant de dire ce qu’un tel utilisateur peut faire sur l’application soient en place.
Les restrictions sur ce que les utilisateurs authentifiés sont autorisés à faire ne sont souvent pas correctement appliquées. Les attaquants peuvent exploiter ces failles pour accéder à des fonctionnalités et/ou données non autorisées, telles que l'accès aux comptes d'autres utilisateurs, l'affichage de fichiers sensibles, la modification des données d'autres utilisateurs, la modification des droits d'accès, etc.
\subsection{A6 : 2017 – MAUVAISE CONFIGURATION DE SECURITE}
La sécurité d’une application Web ne concerne pas seulement le code. D’après l’Owasp, la mauvaise configuration de sécurité est le problème le plus souvent rencontré. Ceci est généralement le résultat de configurations par défaut non sécurisées, de configurations incomplètes, d'un stockage cloud ouvert, d'en-têtes HTTP mal configurés, de messages d'erreur détaillés contenant des informations sensibles, entre autres. Une sécurité renforcée nécessite un ensemble de configurations correctes et sécurisées déployées pour les applications, les frameworks, les serveurs, les bases de données et le code. De même, toutes ces configurations doivent être maintenues à jour.
\subsection{A7 : 2017 – CROSS-SITE SCRIPTING (XSS)}
Les failles XSS se produisent lorsqu'une application accepte des données non fiables et les envoie à un browser web sans validation appropriée. XSS permet à des attaquants d'exécuter du script dans le navigateur de la victime afin de détourner des sessions utilisateur, défigurer des sites web, insérer du contenu hostile, effectuer des attaques par phishing, et prendre le contrôle du navigateur de l'utilisateur en utilisant un script malicieux. Le script malicieux est habituellement écrit en JavaScript, mais n'importe quel langage de programmation supporté par le navigateur de la victime est un moyen d’exécution de cette attaque.
\subsection{A8 : 2017 – DESERIALISATION NON SECURISEE}
La sérialisation est le processus consistant à transformer un objet en un format pouvant être restauré plus tard. Les objets sont le plus souvent sérialisés afin d’être sauvegardés ou d’être transmis dans le cadre d’une communication. La désérialisation est le processus inverse, c'est-à-dire le fait de prendre des données structurées à partir d'un certain format et de les reconstruire en un objet. Une désérialisation non sécurisée conduit souvent à l'exécution de code distant, et même si les failles de désérialisation n'aboutissent pas à l'exécution de code distant, elles peuvent être utilisées pour effectuer des attaques, y compris des attaques d'injection et d'escalade de privilèges.
\subsection{A9 : 2017 – UTILISATION DE COMPOSANTS VULNERABLES}
Les composants logiciels, bibliothèques et frameworks utilisés dans les applications Web proviennent le plus souvent de la communauté open source et doivent être utilisés avec prudence au cas où des vulnérabilités s’y cacheraient. En effet certaines versions d’un composant peuvent être sujettes à diverses vulnérabilités qui pourraient avoir été corrigées dans les versions les plus récentes. Une fois qu'une vulnérabilité est révélée, les failles sont rendues publiques. Ces failles peuvent ensuite être utilisées pour compromettre avec succès la version vulnérable d’un composant et par le même biais, les applications l’utilisant.
\subsection{A10 : 2017 – LOGGING ET MONITORING INSUFFISANTS}
Les événements tels que les tentatives de connexion réussies et infructueuses, l'adresse IP des connexions entrantes, les événements importants tels que les transactions de grande valeur doivent être enregistrés et surveillés régulièrement. Ce faisant, l’on peut comprendre tout ce qui se passe sur l’application et être prêt à réagir en cas d’attaque. Autrement, il peut être très difficile de répondre à une attaque ou de connaître l’origine d’une certaine faille.
\section{Le Protocole SSL}
Le protocole SSL vient en réponse à la préoccupation croissante de la sécurité sur Internet et tire profit des nouveaux algorithmes de chiffrement tels que l’AES venu remplacé le DES et jugé très sécurisé. \\
L’objectif du protocole SSL est de créer un canal de données sécurisé entre le client et le serveur. SSL fournit des améliorations de sécurité au protocole HTTP utilisé jusqu'alors. 
SSL assure 3 choses:
\begin{itemize}
	\itemcheck la confidentialité avec des mécanismes de chiffrements ;
	\itemcheck l’intégrité avec le hachage des données transmises ;
	\itemcheck l’authentification avec l’utilisation de certificats.
\end{itemize}
\subsection{Les certificats}
Pour être sûr que la clé publique provient bien de celui que l'on croit, on utilise une autorité tierce (appelé le tiers de confiance). Cette autorité est celle qui va générer une clé publique certifiée par exemple pour un serveur Web, puis c'est ensuite elle qui garantira à tout demandeur (par exemple le client web) que la clé publique envoyée appartient bien à celui qui le prétend (au serveur Web).La garantie qu'une clé publique provient bien de l'émetteur qu'il prétend être, s'effectue donc via un certificat d'authenticité émanant d'une autorité de certification (AC), le tiers de confiance.\\
Un certificat est un simple fichier informatique délivré par une autorité de certification qui contient :
\begin{itemize}
	 \item la clé publique liée à la clé privée de son détenteur et des informations sur son identité ;
	 \item le nom distinctif de l'autorité de certification ;
	 \item la signature électronique (chiffrement de l'empreinte par clé privée) de l'autorité de certification.
\end{itemize}
C’est ce certificat qui permet d’initialiser une connexion SSL.
\subsection{Fonctionnement de SSL}
SSL consiste en 2 protocoles:
\begin{itemize}
	\itemcheck SSL Handshake protocol: avant de communiquer, les 2 programmes SSL négocient des clés et des protocoles de chiffrement communs.
	\itemcheck SSL Record protocol: Une fois négociés, ils chiffrent toutes les informations échangées et effectuent divers contrôles.
\end{itemize}

\textbf{\RIGHTarrow La négociation SSL}\\
Au début de la communication le client et le serveur s'échangent:
\begin{itemize}
	\itemcheck la version SSL avec laquelle ils veulent communiquer ;
	\itemcheck la liste des méthodes de chiffrement (symétrique et asymétrique) et de signature que chacun connaît (avec longueurs de clés),
	\itemcheck les méthodes de compression que chacun connaît ;
	\itemcheck des nombres aléatoires ;
	\itemcheck les certificats.
\end{itemize}
Client et serveur essaient d'utiliser le protocole de chiffrement le plus puissant et diminuent jusqu'à trouver un protocole commun aux deux. Une fois que cela est fait, ils peuvent commencer à échanger des données.\\

\textbf{\RIGHTarrow La communication SSL}\\ 
Avec SSL, l'expéditeur des données :
\begin{enumerate}
	\item découpe les données en paquets ;
	\item compresse les données ;
	\item signe cryptographiquement les données ;
	\item chiffre les données ;
	\item les envoie.
\end{enumerate}
Celui qui réceptionne les données:
\begin{enumerate}
	\item déchiffre les données,
	\item vérifie la signature des données,
	\item décompresse les données,
	\item réassemble les paquets de données.\\
\end{enumerate}

SSL utilise:
\begin{itemize}
	\itemcheck un système de chiffrement asymétrique (comme RSA ou Diffie-Hellman). Vous pouvez Ce système est utilisé pour générer la clé principale qui permettra de générer des clés de session ;
	\itemcheck un système de chiffrement symétrique (DES, 3DES, IDEA, RC4...) en utilisant les clés de session pour chiffrer les données ;
	\itemcheck un système de signature cryptographique des messages (HMAC, utilisant MD5, SHA...) pour s'assurer que les messages ne sont pas corrompus.
\end{itemize}
C'est lors de la négociation SSL que le client et le serveur choisissent les différents algorithmes qu’ils utiliseront tout au long de leur communication.
Avec le protocole SSL, la sécurité a été sensiblement améliorée. Bien que, comme tout système de chiffrement, le SSL/TLS ne pourra jamais être totalement infaillible, le grand nombre de banques et de sites de commerce électronique l'utilisant pour protéger les transactions de leurs clients peut être considéré comme un gage de sa résistance aux attaques malveillantes. Il faut noter cependant que SSL ne garantit que le transport sécurisé des messages.
SSL est un protocole indépendant qui peut être appliqué à plusieurs autres protocoles. Son utilisation la plus connue est son association avec le protocole HTTP connue comme le protocole HTTPS pour dire, chez certain HTTP over SSL et pour d’autres HTTP Secure. Il a en outre d’autres applications telles que le SSH permettant la connexion à une machine distante et le FTPS permettant le transfert de fichiers.

\section{Entêtes HTTP relatives à la sécurité}
Voici une liste d'entêtes HTTP relatives à la sécurité que les applications doivent considérer :
\begin{itemize}
	\itemcheck HTTP Strict Transport Security (HSTS) : \\
	HSTS est un mécanisme de stratégie de sécurité Web qui aide à protéger les sites Web contre les attaques par dégradation de protocole et le piratage de cookies.
	\itemcheck Public Key Pinning Extension for HTTP (HPKP) : \\
	Le pinning de clé publique HTTP (HPKP) est un mécanisme qui permet aux sites Web HTTPS de se protéger des attaques utilisant des certificats mal émis ou frauduleux.
	\itemcheck X-Frame-Options : \\
	L'entête de réponse X-Frame-Options améliore la protection des applications Web contre le détournement de session par clic.
	\itemcheck X-XSS-Protection : \\
	Cet entête active le filtre XSS dans le navigateur client.
	\itemcheck X-Content-Type-Options : \\
	La définition de cet entête empêchera le navigateur d'interpréter les fichiers comme autre chose que ce qui est déclaré par le type de contenu dans les entêtes HTTP.
	\itemcheck Content-Security-Policy : \\
	Si activé, CSP a un impact significatif sur la façon dont les navigateurs rendent les pages (par exemple, le JavaScript intégré est désactivé par défaut et doit être explicitement autorisé dans la stratégie).
	\itemcheck Referrer-Policy : \\
	L'entête HTTP Referrer-Policy détermine quelles informations sur le référent, envoyées dans l'entête Referer, doivent être incluses dans les requêtes effectuées vers le serveur.
	\itemcheck Expect-CT : \\
	L'entête Expect-CT est utilisé par un serveur pour indiquer que les navigateurs doivent évaluer les connexions à l'hôte émettant l'en-tête pour garantir la conformité de la transparence du certificat.
	\itemcheck Feature-Policy : \\
	L’entête Feature-Policy permet aux développeurs d’activer et de désactiver de manière sélective l’utilisation de diverses fonctionnalités et API du navigateur.
\end{itemize}

\section{Authentification HTTP Digest}
L’authentification digest est un peu  complexe à implémenter mais a le mérite de ne pas transférer les mots de passe en clair. Elle a été mise en place pour pallier les limitations de l’authentification basique. Elle n’envoie pas le mot de passe en clair dans la requête mais procède à l’authentification par un échange de challenge/réponse.\\
Le challenge est envoyé par le serveur en réponse à l’initiation de l’échange par le client. Il contient notamment un “nonce” unique à chaque processus d’authentification Digest et un code qui porte le petit d’”opaque” et doit être retourné au serveur dans la réponse au challenge. Dans sa réponse l’utilisateur spécifie son identité (le paramètre username) et la réponse au challenge posé par le serveur. \\
Cette réponse contient un certain nombre d’informations dont un hash calculé avec l'algorithme MD5 comme suit :
\begin{verbatim}
	Hash = MD5(username:password:realm)
\end{verbatim}
Ce hash et le login (username) permettent au serveur d’authentifier l’utilisateur. Cela nécessite cependant que le serveur stocke le hash.
Pour faire simple, l'authentification HTTP digest fonctionne comme suit:
\begin{enumerate}
	\item un client envoie une requête à un serveur ; 
	\item le serveur répond avec un code spécial (appelé un nonce, un nombre utilisé une seule fois), une autre chaîne représentant le domaine (un hachage) et demande au client de s'authentifier ;
	\item le client répond avec ce nonce et une version cryptée du nom d'utilisateur, mot de passe et domaine (un hachage) ;
	\itemcheck le serveur répond avec les informations demandées si le hash client correspond à son propre hash du nom d'utilisateur, mot de passe et domaine, ou une erreur sinon.
\end{enumerate}

%\includepdf[page=-]{Résumé-Top10-Owasp-by1}0
%\includepdf[page=-]{OWASP-Top10-2017}

